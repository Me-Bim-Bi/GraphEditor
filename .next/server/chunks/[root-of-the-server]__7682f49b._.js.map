{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 97, "column": 0}, "map": {"version":3,"sources":["file:///Users/chuhathanh/Workspaces/Thanhs-Workspaces/GraphEditor/src/app/lib/neo4j.ts"],"sourcesContent":["import neo4j, { QueryResult } from 'neo4j-driver'\n\nconst driver = neo4j.driver(\n    process.env.NEO4J_URI || 'bolt://localhost:7687' as string,\n    neo4j.auth.basic(\n        process.env.NEO4J_USERNAME as string,\n        process.env.NEO4J_PASSWORD as string\n    )\n)\nexport const getSession = () => driver.session();\n\nexport async function cleanDatabase() {\n    const session = driver.session();\n\n    try {\n        await session.run(`\n        MATCH (n)\n        DETACH DELETE n\n    `);\n        console.log('Database cleaned successfully.');\n    } catch (error) {\n        console.error('Error cleaning database:', error);\n    } finally {\n        await session.close();\n    }\n}\n\nexport async function dropGraph() {\n    const session = driver.session();\n\n    try {\n        await session.run(`\n        CALL gds.graph.drop('TestGraph')\n        YIELD graphName\n    `);\n        console.log('Graph dropped successfully.');\n    } catch (error) {\n        console.error('Error dropping graph:', error);\n    } finally {\n        await session.close();\n    }\n}\n\nexport async function createGraph() {\n    const session = driver.session();\n\n    try {\n        const relTypesResult = await session.run(`CALL db.relationshipTypes()`);\n        const relTypes = relTypesResult.records.map(r => r.get(0));\n\n        if (relTypes.length === 0) {\n            throw new Error('No relationship found in database!');\n        }\n\n        const relProjection = relTypes\n            .map(type => `${type}: {orientation: 'NATURAL', properties: ['value']}`)\n            .join(',\\n                        ');\n\n\n        const cypher = `\n            CALL gds.graph.project(\n                'TestGraph',\n                'Node',\n                {\n                    ${relProjection}\n                }\n            )\n        `;\n        await session.run(cypher);\n\n        console.log(`Graph created successfully with relationships: ${relTypes.join(', ')}`);\n    } catch (error) {\n        console.error('Error creating graph:', error);\n    } finally {\n        await session.close();\n    }\n}\n\nexport async function getShortestPath(startId: string, endId: string): Promise<QueryResult> {\n    const session = driver.session();\n\n    try {\n        const result = await session.run(`\n            MATCH (source:Node {id: '${startId}'}), (target:Node {id: '${endId}'})\n            CALL gds.shortestPath.dijkstra.stream('TestGraph', {\n                sourceNode: id(source),\n                targetNodes: id(target),\n                relationshipWeightProperty: 'value'\n            })\n            YIELD index, sourceNode, targetNode, totalCost, nodeIds, costs, path\n            RETURN\n                index,\n                gds.util.asNode(sourceNode).label AS sourceNodeName,\n                gds.util.asNode(targetNode).label AS targetNodeName,\n                totalCost,\n                [nodeId IN nodeIds | gds.util.asNode(nodeId).label] AS nodeNames,\n                costs,\n                nodes(path) as path\n            ORDER BY index\n            `);\n        return result;\n    } catch (error) {\n        console.error('Error fetching shortest path:', error);\n        throw error;\n    } finally {\n        await session.close();\n    }\n}\n\nexport async function communityDetection(): Promise<QueryResult> {\n    const session = driver.session();\n\n    try {\n        const result = await session.run(`\n        CALL gds.louvain.stream('TestGraph')\n        YIELD nodeId, communityId\n        WITH gds.util.asNode(nodeId) AS node, communityId\n        OPTIONAL MATCH (parent:Node)-[:PARENT_CHILD]->(node)\n        RETURN \n            node.id AS id,\n            node.label AS node,\n            communityId AS score,\n            parent.id AS parentID\n        ORDER BY communityId DESC, node ASC\n            `);\n        return result;\n    } catch (error) {\n        console.error('Error performing community detection:', error);\n        throw error;\n    } finally {\n        await session.close();\n    }\n}\n\nexport async function pageRank(): Promise<QueryResult> {\n    const session = driver.session();\n\n    try {\n        const result = await session.run(`\n            CALL gds.pageRank.stream('TestGraph')\n            YIELD nodeId, score\n            WITH gds.util.asNode(nodeId) AS node, score\n            OPTIONAL MATCH (parent:Node)-[:PARENT_CHILD]->(node)\n            RETURN \n                node.id AS id,\n                node.label AS node,\n                score,\n                parent.id AS parentID\n            ORDER BY score DESC, node ASC\n            `);\n        return result;\n    } catch (error) {\n        console.error('Error performing page rank:', error);\n        throw error;\n    } finally {\n        await session.close();\n    }\n}\n\nexport async function degreeCentrality(): Promise<QueryResult> {\n    const session = driver.session();\n\n    try {\n        const result = await session.run(`\n            CALL gds.degree.stream('TestGraph')\n            YIELD nodeId, score\n            WITH gds.util.asNode(nodeId) AS node, score\n            OPTIONAL MATCH (parent:Node)-[:PARENT_CHILD]->(node)\n            RETURN\n                node.id AS id,\n                node.label AS node,\n                score,\n                parent.id AS parentID\n            ORDER BY score DESC, node ASC\n            `);\n        return result;\n    } catch (error) {\n        console.error('Error performing degree centrality:', error);\n        throw error;\n    } finally {\n        await session.close();\n    }\n}\n\nexport async function connectedComponents(): Promise<QueryResult> {\n    const session = driver.session();\n\n    try {\n        const result = await session.run(`\n            CALL gds.scc.stream('TestGraph')\n            YIELD nodeId, componentId\n            WITH gds.util.asNode(nodeId) AS node, componentId AS score\n            OPTIONAL MATCH (parent:Node)-[:PARENT_CHILD]->(node)\n            RETURN\n                node.id AS id,\n                node.label AS node,\n                score,\n                parent.id AS parentID\n            ORDER BY score DESC, node ASC\n\n            `);\n        return result;\n    } catch (error) {\n        console.error('Error performing strong connected components:', error);\n        throw error;\n    } finally {\n        await session.close();\n    }\n}\n\nexport async function getNeighbors(findNeighborsLabel: string, hop: string): Promise<QueryResult> {\n    const session = driver.session();\n    try {\n        const hopNum = Math.min(Number(hop) || 1, 5);\n\n        const relTypesResult = await session.run(`CALL db.relationshipTypes()`);\n        const relTypes = relTypesResult.records.map(r => r.get(0));\n\n        if (relTypes.length === 0) {\n            throw new Error('No relationship types found in database!');\n        }\n\n        const relPattern = relTypes.join('|');\n\n        const query = `\n      MATCH p=(n:Node {id: $findNeighborsLabel})-[:${relPattern}*1..${hopNum}]-(m:Node)\n      RETURN p\n    `;\n\n        const result = await session.run(query, { findNeighborsLabel });\n        return result;\n    } catch (error) {\n        console.error('Error finding neighbors:', error);\n        throw error;\n    } finally {\n        await session.close();\n    }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 328, "column": 0}, "map": {"version":3,"sources":["file:///Users/chuhathanh/Workspaces/Thanhs-Workspaces/GraphEditor/src/app/api/clear/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { getSession, cleanDatabase } from '../../lib/neo4j';\n\nexport async function POST(req: NextRequest) {\n    const session = getSession();\n    \n    try {\n        const result = await cleanDatabase();\n        return NextResponse.json({ message: 'Clear graph successful!'});\n    } catch (error) {\n        console.error(error);\n        return NextResponse.json({ message: 'Error clearning graph', error }, { status: 500 });\n    } finally {\n        await session.close();\n    }   \n}"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,GAAgB;IACvC,MAAM,UAAU,IAAA,+LAAU;IAE1B,IAAI;QACA,MAAM,SAAS,MAAM,IAAA,kMAAa;QAClC,OAAO,sWAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAyB;IACjE,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC;QACd,OAAO,sWAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAyB;QAAM,GAAG;YAAE,QAAQ;QAAI;IACxF,SAAU;QACN,MAAM,QAAQ,KAAK;IACvB;AACJ","debugId":null}}]
}